# -*- coding: utf-8 -*-
"""RiskaPakapesNovertesanasRisinajums.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M7jy9RmOo5v82xxrGQCFI3US7PFgq7-8
"""

import pandas as pd
pd.options.mode.copy_on_write = True  #Kāpēc tika pielietota - https://pandas.pydata.org/docs/user_guide/copy_on_write.html
import numpy as np
from pandas.api.types import is_numeric_dtype
!pip install pygad
import pygad
!pip install prophet
from prophet import Prophet
from datetime import datetime
import os

df2 = pd.read_json('Dati.json')
df = df2[['received_at', 'co2','humidity', 'distance','density', 'employee_group_separation','mask_wearing', 'desinfector_availability','time_spent_together', 'waste_water','productivity']]

#----------------------------------------Datu pirmsapstrāde-----------------------------------------------------------------------------------------
for kolonna in df:
    if kolonna=='received_at':
        continue
    if is_numeric_dtype(df[kolonna])==False:
      df[kolonna] = pd.to_numeric(df[kolonna], errors='coerce')

df["employee_group_separation"]=np.where(df["employee_group_separation"]<0, np.nan, df["employee_group_separation"])
df["employee_group_separation"]=np.where(df["employee_group_separation"]>5, np.nan, df["employee_group_separation"])

df["desinfector_availability"]=np.where(df["desinfector_availability"]<0, np.nan, df["desinfector_availability"])
df["desinfector_availability"]=np.where(df["desinfector_availability"]>1, np.nan, df["desinfector_availability"])

for kolonna in df:
    if kolonna=='received_at' or kolonna=='employee_group_separation' or kolonna=='desinfector_availability' : 
      continue
    df[kolonna] = np.where(df[kolonna]<0,np.nan, df[kolonna])

for kolonna in df:
    if kolonna=='received_at' or kolonna=='desinfector_availability' or kolonna=='employee_group_separation':
      continue
    Q1=df[kolonna].quantile(0.25) 
    Q3=df[kolonna].quantile(0.75)
    IQR=Q3-Q1
    lower_lim=Q1 - (1.5 * IQR)
    upper_lim=Q3 + (1.5 * IQR)
    df[kolonna] = np.where(df[kolonna].notnull(),np.where(df[kolonna] > upper_lim, np.nan,
                          np.where(df[kolonna] < lower_lim, np.nan,
                                   df[kolonna])),df[kolonna])

df['desinfector_availability'].interpolate(method='pad', limit=None, inplace=True, limit_direction='forward')
df['desinfector_availability'].interpolate(inplace=True, limit_direction='both')

from scipy.interpolate import Rbf
for kolonna in df:
    if kolonna=='received_at' or kolonna=='desinfector_availability':
        continue
    if df[kolonna].isnull().sum() > 0:
        df_beznan = df[kolonna].dropna()
        interp_func = Rbf(df_beznan.index, df_beznan.values)
        df[kolonna]=np.where(df[kolonna].isnull(),interp_func(df.index),df[kolonna]) # aizpilda tikai tukšas vērtības

kolonnas=['co2','distance', 'employee_group_separation','mask_wearing', 'desinfector_availability', 'waste_water']
df[kolonnas] = df[kolonnas].apply(np.int64)

for kolonna in df:
  if kolonna=='received_at' or kolonna=='desinfector_availability':
    continue
  df[kolonna] = np.where(df[kolonna]<0,0, df[kolonna])
  if kolonna=='employee_group_separation':
    df[kolonna]=np.where(df[kolonna]>5, 5, df[kolonna])

df['humidity'] = df['humidity'].round(2)
df['density']= df['density'].round(2)
df['time_spent_together'] = df['time_spent_together'].round(2)
df['productivity'] = df['productivity'].round(2)

df2=df.copy()
#------------------------------Riska rādītāja aprēķins un svaru optimizācija-------------------------------------------------------------------------------------
def MaskWearing(mask):
    if (mask==0):
        mask=0
    if (mask==1):
        mask=1
    if (mask>=2):
        mask=3
    return mask

def CO2Impact(c02):
  if c02 <800:
    c02=1
  if (c02>=800 and c02<1000):
    c02=2
  if c02>=1000:
    c02=3
  return c02

def HumidityImpact(hum):
  if (hum>=60 or hum <=40):
    hum=2
  else:
    hum=0
  return hum

def Desinfectant(dez):
    if dez==0:
        dez=3
    else:
        dez=0
    return dez

def VirusWater(water):
    if water<100:
        water=1
    if (water>=100)and(water<10000000):
        water=4
    if (water>=10000000):
        water=5
    return water

def Distance(distance):
    if distance<50:
        distance=3
    if (distance>=50)and (distance<100):
        distance=2
    if (distance>=100)and(distance<200):
        distance=1
    if distance>=200:
        distance=0
    return distance

def Density(density):
    if density<1:
        density=3
    if (density>=1)and(density<2):
        density=2
    if (density>=2)and(density<4):
        density=1
    if (density>=4):
        density=0
    return density

def Group(group):
    if group==5:
        group=3
    if (group>=3) and (group<5):
        group=2
    if group==2:
        group=1
    else:
        group=0
    return group

def Time(time):
    if time>=1:
        time=3
    if (time>=0.5)and(time<1):
        time=2
    if (time>=0.25)and(time<0.5):
        time=1
    if time<0.25:
        time=0
    return time
    

df["I"] = " "
wTeor = [0.198, 0.005, 0.15, 0.04, 0.01, 0.15, 0.001, 0.045, 0.4]

for rinda in df.index:

    df.loc[rinda, 'mask_wearing'] = MaskWearing(df.loc[rinda, 'mask_wearing'])
    
    df.loc[rinda, 'co2'] = CO2Impact(df.loc[rinda, 'co2'])
    
    df.loc[rinda, 'humidity'] = HumidityImpact(df.loc[rinda, 'humidity'])
    
    df.loc[rinda, 'desinfector_availability']=Desinfectant(df.loc[rinda, 'desinfector_availability'])
    
    df.loc[rinda, 'waste_water']= VirusWater(df.loc[rinda, 'waste_water'])
                               
    df.loc[rinda, 'distance']= Distance(df.loc[rinda, 'distance'])
    
    df.loc[rinda, 'density']= Density(df.loc[rinda, 'density'])
    
    df.loc[rinda, 'employee_group_separation']=Group(df.loc[rinda, 'employee_group_separation'])
    
    df.loc[rinda, 'time_spent_together']=Time(df.loc[rinda, 'time_spent_together'])
    
    RiskVisp=0  
    for num in range(len(wTeor)):
        RiskVisp +=wTeor[num]*df.iloc[rinda, num+1]
    df.loc[rinda, 'I'] = RiskVisp
  

summaIx=0.0
summaPy=0.0
summaIP=0.0
summaI2=0.0
for rinda in df.index:
  summaIx = summaIx + df.loc[rinda, 'I']
  summaPy = summaPy + df.loc[rinda, 'productivity']
  summaI2 = summaI2 + (df.loc[rinda, 'I'] * df.loc[rinda, 'I'])
  summaIP= summaIP + (df.loc[rinda, 'I'] * df.loc[rinda, 'productivity'])

Ix = summaIx/len(df.index)
Py = summaPy/len(df.index)

pirmais=summaIP-((summaIx*summaPy)/len(df.index))
otrais=summaI2-((summaIx*summaIx)/len(df.index))
B1=pirmais/otrais
a=Py - B1*Ix 

#GA modelis tika aizgūts no https://pypi.org/project/geneticalgorithm/ un modificēts bakalaura darba vajadzībām

def aprekinat(svari, rinda):
  return (a+B1*np.sum(svari * np.array(rinda)))

def kluda(svari, vertibas, produktivitate):
    kludas = []
    for i in np.arange(len(produktivitate)):
      aprekinata = aprekinat(svari, vertibas.iloc[i])
      noverota = produktivitate.iloc[i]
      kludas.append((noverota - aprekinata) ** 2)
    return -1*np.sum(kludas) 

def f(ga_instance,atrisinajums, atrisinajums_idx):
    return kluda(atrisinajums,
                df.loc[:, 'co2':'waste_water'],
                df['productivity'])
               
ga_instance = pygad.GA(num_generations=2,
                       save_solutions=True, 
                       sol_per_pop=9, 
                       num_parents_mating=2, 
                       num_genes=9, 
                       gene_type=float, 
                       gene_space =  [{'low': 0.099, 'high': 0.297},{'low': 0.002, 'high': 0.007}, {'low': 0.07, 'high': 0.22},{'low': 0.02, 'high': 0.06},{'low': 0.005, 'high': 0.015},{'low': 0.07, 'high': 0.22},{'low': 0.0005, 'high': 0.0015},{'low': 0.022, 'high': 0.067},{'low': 0.2, 'high': 0.6}],
                       fitness_func=f,
                       mutation_type="adaptive",
                       mutation_probability=[0.7, 0.15], 
                       parent_selection_type = "rws",
                       crossover_type='scattered',
                       crossover_probability=0.15) 
                      # stop_criteria="saturate_100")
ga_instance.run()
atrisinajums, atrisinajums_fitness, atrisinajums_idx = ga_instance.best_solution()

with open('korigetieSvari.txt','a') as f: 
    f.write(str(atrisinajums) + "\n") #https://java2blog.com/write-variable-to-file-python/

#----------------------------------------------------------Riska faktoru nakotnes vertibu prognozesana-------------------------------------------------------------------------
if os.stat('datums.txt').st_size == 0:
  pedejaRinda = df.iloc[-1]
  risksTagad=0
  for num in range(len(atrisinajums)):
    risksTagad += atrisinajums[num]*pedejaRinda[num+1]
  print('Riska ietekme uz doto brīdi ar pārrēķinātiem svariem :', risksTagad)
else:
  datne = open('datums.txt', "r")
  end_date=datne.read()
  endd = datetime.strptime(end_date, '%d.%m.%y %H:%M:%S')
  kolonnas=['received_at', 'co2','humidity', 'distance','density', 'employee_group_separation','mask_wearing', 'desinfector_availability','time_spent_together', 'waste_water','productivity']

  Iciti=0 
  if endd.weekday()>=5: 
   #distance=0 
   #density=0
   #employee_group_separation=0
   #mask_wearing=0
   #time_spent_together=0
   Iciti=0
   kolonnas.remove('distance')
   kolonnas.remove('density')
   kolonnas.remove('employee_group_separation')
   kolonnas.remove('mask_wearing')
   kolonnas.remove('time_spent_together')

  else:
    start = datetime(endd.year, endd.month, endd.day, 20, 0, 0)
    end=datetime(endd.year, endd.month, endd.day, 23, 59, 59) 
    if start <= endd <= end:
      #distance=0
      #density=0
      #employee_group_separation=0
      #mask_wearing=0
      #time_spent_together=0
      Iciti=0
      kolonnas.remove('distance')
      kolonnas.remove('density')
      kolonnas.remove('employee_group_separation')
      kolonnas.remove('mask_wearing')
      kolonnas.remove('time_spent_together')
  
    start = datetime(endd.year, endd.month, endd.day, 10, 0, 0)
    end=datetime(endd.year, endd.month, endd.day, 11, 0, 0)
    if start <= endd <= end:
      if endd.weekday()==0:
        employee_group_separation=3
        Iciti=2*atrisinajums[4]
        kolonnas.remove('employee_group_separation')
      if endd.weekday()==1: 
        employee_group_separation=2
        Iciti=1*atrisinajums[4]
        kolonnas.remove('employee_group_separation')
      if endd.weekday()==2: 
        employee_group_separation=4
        Iciti=2*atrisinajums[4]
        kolonnas.remove('employee_group_separation')
      if endd.weekday()>2:
        employee_group_separation=3
        Iciti=2*atrisinajums[4]
        kolonnas.remove('employee_group_separation')



  #prognozēšanas modelis tika aizgūts no https://medium.com/grabngoinfo/3-ways-for-multiple-time-series-forecasting-using-prophet-in-python-7a0709a117f9

  data=df2[kolonnas]

  kolonnas.remove('received_at')
  data = pd.melt(data, id_vars='received_at', value_vars=kolonnas)
  data.columns = ['ds', 'ticker', 'y']
  grupet_pec_riska_faktora = data.groupby('ticker')

  sakuma_laiks = df['received_at'].iloc[-1]
  cik_dienas = pd.date_range( start=sakuma_laiks, end=endd, freq='10min')
  periodi=cik_dienas.size

  def train_and_forecast(riska_faktors):
    modelis = Prophet()
    modelis.fit(riska_faktors)
    nakotne = modelis.make_future_dataframe(periods=periodi,freq='10min')
    forecast = modelis.predict(nakotne)[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]
    forecast['ticker'] = riska_faktors['ticker'].iloc[0]
    return forecast[['ds', 'ticker', 'yhat', 'yhat_upper', 'yhat_lower']]

  for_loop_forecast = pd.DataFrame()
  riska_faktori=kolonnas
  for faktors in riska_faktori:
    riska_faktors = grupet_pec_riska_faktora.get_group(faktors)  
    forecast = train_and_forecast(riska_faktors)
    for_loop_forecast = pd.concat((for_loop_forecast, forecast))

  for_loop_forecast=pd.pivot(for_loop_forecast, index='ds', columns='ticker', values='yhat')

  Ikolonnas=0

  for kolonna in for_loop_forecast.columns:
    for_loop_forecast[kolonna] = np.where(for_loop_forecast[kolonna]<0,0, for_loop_forecast[kolonna])
    for_loop_forecast[kolonna]=for_loop_forecast[kolonna].round(0)
    for_loop_forecast[kolonna] = for_loop_forecast[kolonna].apply(np.int64)

    if kolonna=='mask_wearing':
      mask_wearing=MaskWearing(for_loop_forecast['mask_wearing'].iloc[-1])
      Ikolonnas=Ikolonnas+mask_wearing*atrisinajums[5]

    if kolonna=='co2':
      co2=CO2Impact(for_loop_forecast['co2'].iloc[-1])
      Ikolonnas=Ikolonnas+co2*atrisinajums[0]

    if kolonna=='humidity':
      humidity=HumidityImpact(for_loop_forecast['humidity'].iloc[-1])
      Ikolonnas=Ikolonnas+humidity*atrisinajums[1]

    if kolonna=='desinfector_availability':
      desinfector_availability=Desinfectant(for_loop_forecast['desinfector_availability'].iloc[-1])
      Ikolonnas=Ikolonnas+desinfector_availability*atrisinajums[6]

    if kolonna=='waste_water':
      waste_water=VirusWater(for_loop_forecast['waste_water'].iloc[-1])
      Ikolonnas=Ikolonnas+waste_water*atrisinajums[8]

    if kolonna=='distance':
      distance=Distance(for_loop_forecast['distance'].iloc[-1])
      Ikolonnas=Ikolonnas+distance*atrisinajums[2]

    if kolonna=='density':
      density=Density(for_loop_forecast['density'].iloc[-1])
      Ikolonnas=Ikolonnas+density*atrisinajums[3]

    if kolonna=='employee_group_separation':
      for_loop_forecast[kolonna]=np.where(for_loop_forecast[kolonna]>5, 5, for_loop_forecast[kolonna])
      employee_group_separation=Group(for_loop_forecast['employee_group_separation'].iloc[-1])
      Ikolonnas=Ikolonnas+employee_group_separation*atrisinajums[4]

    if kolonna=='time_spent_together':
      time_spent_together=Time(for_loop_forecast['time_spent_together'].iloc[-1])
      Ikolonnas=Ikolonnas+time_spent_together*atrisinajums[7]

  Inakotne=Ikolonnas + Iciti
  print('Riska ietekme nākotnes momentā :', Inakotne)



