# -*- coding: utf-8 -*-
"""RiskaPakapesNovertesanasRisinajums.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M7jy9RmOo5v82xxrGQCFI3US7PFgq7-8
"""

import pandas as pd
pd.options.mode.copy_on_write = True
import numpy as np
from pandas.api.types import is_numeric_dtype
!pip install pygad
import pygad
!pip install prophet
from prophet import Prophet
from datetime import datetime
import os

df2 = pd.read_json('Dati.json')
df = df2[['received_at', 'co2','humidity', 'distance','density', 'employee_group_separation','mask_wearing', 'desinfector_availability','time_spent_together', 'waste_water','productivity']]

#----------------------------------------Datu pirmsapstrāde-----------------------------------------------------------------------------------------
for column in df:
    if column=='received_at':
        continue
    if is_numeric_dtype(df[column])==False:
      df[column] = pd.to_numeric(df[column], errors='coerce')

df["employee_group_separation"]=np.where(df["employee_group_separation"]<0, np.nan, df["employee_group_separation"])
df["employee_group_separation"]=np.where(df["employee_group_separation"]>5, np.nan, df["employee_group_separation"])

df["desinfector_availability"]=np.where(df["desinfector_availability"]<0, np.nan, df["desinfector_availability"])
df["desinfector_availability"]=np.where(df["desinfector_availability"]>1, np.nan, df["desinfector_availability"])

for column in df:
    if column=='received_at' or column=='employee_group_separation' or column=='desinfector_availability' : 
      continue
    df[column] = np.where(df[column]<0,np.nan, df[column])

for column in df:
    if column=='received_at' or column=='desinfector_availability' or column=='employee_group_separation':
      continue
    Q1=df[column].quantile(0.25) 
    Q3=df[column].quantile(0.75)
    IQR=Q3-Q1
    lower_lim=Q1 - (1.5 * IQR)
    upper_lim=Q3 + (1.5 * IQR)
    df[column] = np.where(df[column].notnull(),np.where(df[column] > upper_lim, np.nan,
                          np.where(df[column] < lower_lim, np.nan,
                                   df[column])),df[column])

df['desinfector_availability'].interpolate(method='pad', limit=None, inplace=True, limit_direction='forward')
df['desinfector_availability'].interpolate(inplace=True, limit_direction='both')

from scipy.interpolate import Rbf
for column in df:
    if column=='received_at' or column=='desinfector_availability':
        continue
    if df[column].isnull().sum() > 0:
        fit_df = df[column].dropna()
        interp_func = Rbf(fit_df.index, fit_df.values)
        df[column]=np.where(df[column].isnull(),interp_func(df.index),df[column]) # aizpilda tikai tukšas vērtības

kolonnas=['co2','distance', 'employee_group_separation','mask_wearing', 'desinfector_availability', 'waste_water']
df[kolonnas] = df[kolonnas].apply(np.int64)

for column in df:
  if column=='received_at' or column=='desinfector_availability':
    continue
  df[column] = np.where(df[column]<0,0, df[column])
  if column=='employee_group_separation':
    df[column]=np.where(df[column]>5, 5, df[column])

df['humidity'] = df['humidity'].round(2)
df['density']= df['density'].round(2)
df['time_spent_together'] = df['time_spent_together'].round(2)
df['productivity'] = df['productivity'].round(2)

df2=df.copy()
#------------------------------Riska rādītāja aprēķins un svaru optimizācija-------------------------------------------------------------------------------------
def MaskWearing(mask):
    if (mask==0):
        mask=0
    if (mask==1):
        mask=1
    if (mask>=2):
        mask=3
    return mask

def CO2Impact(param):
  if param <800:
    param=1
  if (param>=800 and param<1000):
    param=2
  if param>=1000:
    param=3
  return param

def HumidityImpact(param):
  if (param>=60 or param <=40):
    param=2
  else:
    param=0
  return param

def Desinfectant(param):
    if param==0:
        param=3
    else:
        param=0
    return param

def VirusWater(param):
    if param<100:
        param=1
    if (param>=100)and(param<10000000):
        param=4
    if (param>=10000000):
        param=5
    return param

def Distance(param):
    if param<50:
        param=3
    if (param>=50)and (param<100):
        param=2
    if (param>=100)and(param<200):
        param=1
    if param>=200:
        param=0
    return param

def Density(param):
    if param<1:
        param=3
    if (param>=1)and(param<2):
        param=2
    if (param>=2)and(param<4):
        param=1
    if (param>=4):
        param=0
    return param

def Group(param):
    if param==5:
        param=3
    if (param>=3) and (param<5):
        param=2
    if param==2:
        param=1
    else:
        param=0
    return param

def Time(param):
    if param>=1:
        param=3
    if (param>=0.5)and(param<1):
        param=2
    if (param>=0.25)and(param<0.5):
        param=1
    if param<0.25:
        param=0
    return param
    

df["I"] = " "
wTeor = [0.198, 0.005, 0.15, 0.04, 0.01, 0.15, 0.001, 0.045, 0.4]

for row in df.index:

    df.loc[row, 'mask_wearing'] = MaskWearing(df.loc[row, 'mask_wearing'])
    
    df.loc[row, 'co2'] = CO2Impact(df.loc[row, 'co2'])
    
    df.loc[row, 'humidity'] = HumidityImpact(df.loc[row, 'humidity'])
    
    df.loc[row, 'desinfector_availability']=Desinfectant(df.loc[row, 'desinfector_availability'])
    
    df.loc[row, 'waste_water']= VirusWater(df.loc[row, 'waste_water'])
                               
    df.loc[row, 'distance']= Distance(df.loc[row, 'distance'])
    
    df.loc[row, 'density']= Density(df.loc[row, 'density'])
    
    df.loc[row, 'employee_group_separation']=Group(df.loc[row, 'employee_group_separation'])
    
    df.loc[row, 'time_spent_together']=Time(df.loc[row, 'time_spent_together'])
    
    RiskVisp=0  
    for num in range(len(wTeor)):
        RiskVisp +=wTeor[num]*df.iloc[row, num+1]
    df.loc[row, 'I'] = RiskVisp
  

summaIx=0.0
summaPy=0.0
summaIP=0.0
summaI2=0.0
for row in df.index:
  summaIx = summaIx + df.loc[row, 'I']
  summaPy = summaPy + df.loc[row, 'productivity']
  summaI2 = summaI2 + (df.loc[row, 'I'] * df.loc[row, 'I'])
  summaIP= summaIP + (df.loc[row, 'I'] * df.loc[row, 'productivity'])

Ix = summaIx/len(df.index)
Py = summaPy/len(df.index)

pirmais=summaIP-((summaIx*summaPy)/len(df.index))
otrais=summaI2-((summaIx*summaIx)/len(df.index))
B1=pirmais/otrais
a=Py - B1*Ix 

def predict(slopes, row):
  return (a+B1*np.sum(slopes * np.array(row)))

def mmse_ga(slopes, attributes, y_values):
    errors = []
    for i in np.arange(len(y_values)):
      predicted = predict(slopes, attributes.iloc[i])
      actual = y_values.iloc[i]
      errors.append((actual - predicted) ** 2)
    return -1*np.sum(errors) 

#https://pypi.org/project/geneticalgorithm/ - GA library
def f(ga_instance,solution, solution_idx):
    return mmse_ga(solution,
                df.loc[:, 'co2':'waste_water'],
                df['productivity'])
               
ga_instance = pygad.GA(num_generations=2,
                       save_solutions=True, 
                       sol_per_pop=9, 
                       num_parents_mating=2, 
                       num_genes=9, 
                       gene_type=float, 
                       gene_space =  [{'low': 0.099, 'high': 0.297},{'low': 0.002, 'high': 0.007}, {'low': 0.07, 'high': 0.22},{'low': 0.02, 'high': 0.06},{'low': 0.005, 'high': 0.015},{'low': 0.07, 'high': 0.22},{'low': 0.0005, 'high': 0.0015},{'low': 0.022, 'high': 0.067},{'low': 0.2, 'high': 0.6}],
                       fitness_func=f,
                       mutation_type="adaptive",
                       mutation_probability=[0.7, 0.15], 
                       parent_selection_type = "rws",
                       crossover_type='scattered',
                       crossover_probability=0.15) 
                      # stop_criteria="saturate_100")
ga_instance.run()
solution, solution_fitness, solution_idx = ga_instance.best_solution()

with open('korigetieSvari.txt','a') as f: 
    f.write(str(solution) + "\n") #https://java2blog.com/write-variable-to-file-python/

#----------------------------------------------------------Riska faktoru nakotnes vertibu prognozesana-------------------------------------------------------------------------
if os.stat('datums.txt').st_size == 0:
  pedejaRinda = df.iloc[-1]
  risksTagad=0
  for num in range(len(solution)):
    risksTagad += solution[num]*pedejaRinda[num+1]
  print('Riska ietekme uz doto brīdi ar pārrēķinātiem svariem :', risksTagad)
else:
  text_file = open('datums.txt', "r")
  end_date=text_file.read()
  endd = datetime.strptime(end_date, '%d.%m.%y %H:%M:%S')
  kolonnas=['received_at', 'co2','humidity', 'distance','density', 'employee_group_separation','mask_wearing', 'desinfector_availability','time_spent_together', 'waste_water','productivity']

  Iciti=0 
  if endd.weekday()>=5: 
   #distance=0 
   #density=0
   #employee_group_separation=0
   #mask_wearing=0
   #time_spent_together=0
   Iciti=0
   kolonnas.remove('distance')
   kolonnas.remove('density')
   kolonnas.remove('employee_group_separation')
   kolonnas.remove('mask_wearing')
   kolonnas.remove('time_spent_together')

  else:
    start = datetime(endd.year, endd.month, endd.day, 20, 0, 0)
    end=datetime(endd.year, endd.month, endd.day, 23, 59, 59) 
    if start <= endd <= end:
      #distance=0
      #density=0
      #employee_group_separation=0
      #mask_wearing=0
      #time_spent_together=0
      Iciti=0
      kolonnas.remove('distance')
      kolonnas.remove('density')
      kolonnas.remove('employee_group_separation')
      kolonnas.remove('mask_wearing')
      kolonnas.remove('time_spent_together')
  
    start = datetime(endd.year, endd.month, endd.day, 10, 0, 0)
    end=datetime(endd.year, endd.month, endd.day, 11, 0, 0)
    if start <= endd <= end:
      if endd.weekday()==0:
        employee_group_separation=3
        Iciti=2*solution[4]
        kolonnas.remove('employee_group_separation')
      if endd.weekday()==1: 
        employee_group_separation=2
        Iciti=1*solution[4]
        kolonnas.remove('employee_group_separation')
      if endd.weekday()==2: 
        employee_group_separation=4
        Iciti=2*solution[4]
        kolonnas.remove('employee_group_separation')
      if endd.weekday()>2:
        employee_group_separation=3
        Iciti=2*solution[4]
        kolonnas.remove('employee_group_separation')



  #https://medium.com/grabngoinfo/3-ways-for-multiple-time-series-forecasting-using-prophet-in-python-7a0709a117f9

  data=df2[kolonnas]

  kolonnas.remove('received_at')
  data = pd.melt(data, id_vars='received_at', value_vars=kolonnas)
  data.columns = ['ds', 'ticker', 'y']
  groups_by_ticker = data.groupby('ticker')

  start_date = df['received_at'].iloc[-1]
  dates = pd.date_range( start=start_date, end=endd, freq='10min')
  per=dates.size

  def train_and_forecast(group):
    m = Prophet()
    m.fit(group)
    future = m.make_future_dataframe(periods=per,freq='10min')
    forecast = m.predict(future)[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]
    forecast['ticker'] = group['ticker'].iloc[0]
    return forecast[['ds', 'ticker', 'yhat', 'yhat_upper', 'yhat_lower']]

  for_loop_forecast = pd.DataFrame()
  ticker_list=kolonnas
  for ticker in ticker_list:
    group = groups_by_ticker.get_group(ticker)  
    forecast = train_and_forecast(group)
    for_loop_forecast = pd.concat((for_loop_forecast, forecast))

  for_loop_forecast=pd.pivot(for_loop_forecast, index='ds', columns='ticker', values='yhat')

  Ikolonnas=0

  for column in for_loop_forecast.columns:
    for_loop_forecast[column] = np.where(for_loop_forecast[column]<0,0, for_loop_forecast[column])
    for_loop_forecast[column]=for_loop_forecast[column].round(0)
    for_loop_forecast[column] = for_loop_forecast[column].apply(np.int64)

    if column=='mask_wearing':
      mask_wearing=MaskWearing(for_loop_forecast['mask_wearing'].iloc[-1])
      Ikolonnas=Ikolonnas+mask_wearing*solution[5]

    if column=='co2':
      co2=CO2Impact(for_loop_forecast['co2'].iloc[-1])
      Ikolonnas=Ikolonnas+co2*solution[0]

    if column=='humidity':
      humidity=HumidityImpact(for_loop_forecast['humidity'].iloc[-1])
      Ikolonnas=Ikolonnas+humidity*solution[1]

    if column=='desinfector_availability':
      desinfector_availability=Desinfectant(for_loop_forecast['desinfector_availability'].iloc[-1])
      Ikolonnas=Ikolonnas+desinfector_availability*solution[6]

    if column=='waste_water':
      waste_water=VirusWater(for_loop_forecast['waste_water'].iloc[-1])
      Ikolonnas=Ikolonnas+waste_water*solution[8]

    if column=='distance':
      distance=Distance(for_loop_forecast['distance'].iloc[-1])
      Ikolonnas=Ikolonnas+distance*solution[2]

    if column=='density':
      density=Density(for_loop_forecast['density'].iloc[-1])
      Ikolonnas=Ikolonnas+density*solution[3]

    if column=='employee_group_separation':
      for_loop_forecast[column]=np.where(for_loop_forecast[column]>5, 5, for_loop_forecast[column])
      employee_group_separation=Group(for_loop_forecast['employee_group_separation'].iloc[-1])
      Ikolonnas=Ikolonnas+employee_group_separation*solution[4]

    if column=='time_spent_together':
      time_spent_together=Time(for_loop_forecast['time_spent_together'].iloc[-1])
      Ikolonnas=Ikolonnas+time_spent_together*solution[7]

  Inakotne=Ikolonnas + Iciti
  print('Riska ietekme nākotnes momentā :', Inakotne)

